// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __seq1__octet_hh__
#define __seq1__octet_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE omg

  _CORBA_MODULE_BEG

    _CORBA_MODULE boxedRMI

    _CORBA_MODULE_BEG

      class _0RL_boxed_seq1_octet_var;

      class _0RL_boxed_seq1_octet : public _CORBA_Unbounded_Sequence_Octet {
      public:
        typedef _0RL_boxed_seq1_octet_var _var_type;
        inline _0RL_boxed_seq1_octet() {}
        inline _0RL_boxed_seq1_octet(const _0RL_boxed_seq1_octet& _s)
          : _CORBA_Unbounded_Sequence_Octet(_s) {}

        inline _0RL_boxed_seq1_octet(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_Octet(_max) {}
        inline _0RL_boxed_seq1_octet(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::Octet* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

      

        inline _0RL_boxed_seq1_octet& operator = (const _0RL_boxed_seq1_octet& _s) {
          _CORBA_Unbounded_Sequence_Octet::operator=(_s);
          return *this;
        }
      };

      class _0RL_boxed_seq1_octet_out;

      class _0RL_boxed_seq1_octet_var {
      public:
        inline _0RL_boxed_seq1_octet_var() : _pd_seq(0) {}
        inline _0RL_boxed_seq1_octet_var(_0RL_boxed_seq1_octet* _s) : _pd_seq(_s) {}
        inline _0RL_boxed_seq1_octet_var(const _0RL_boxed_seq1_octet_var& _s) {
          if( _s._pd_seq )  _pd_seq = new _0RL_boxed_seq1_octet(*_s._pd_seq);
          else              _pd_seq = 0;
        }
        inline ~_0RL_boxed_seq1_octet_var() { if( _pd_seq )  delete _pd_seq; }
          
        inline _0RL_boxed_seq1_octet_var& operator = (_0RL_boxed_seq1_octet* _s) {
          if( _pd_seq )  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline _0RL_boxed_seq1_octet_var& operator = (const _0RL_boxed_seq1_octet_var& _s) {
          if( _s._pd_seq ) {
            if( !_pd_seq )  _pd_seq = new _0RL_boxed_seq1_octet;
            *_pd_seq = *_s._pd_seq;
          } else if( _pd_seq ) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline CORBA::Octet& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline _0RL_boxed_seq1_octet* operator -> () { return _pd_seq; }
        inline const _0RL_boxed_seq1_octet* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
        inline operator _0RL_boxed_seq1_octet& () const { return *_pd_seq; }
#else
        inline operator const _0RL_boxed_seq1_octet& () const { return *_pd_seq; }
        inline operator _0RL_boxed_seq1_octet& () { return *_pd_seq; }
#endif
          
        inline const _0RL_boxed_seq1_octet& in() const { return *_pd_seq; }
        inline _0RL_boxed_seq1_octet&       inout()    { return *_pd_seq; }
        inline _0RL_boxed_seq1_octet*&      out() {
          if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline _0RL_boxed_seq1_octet* _retn() { _0RL_boxed_seq1_octet* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class _0RL_boxed_seq1_octet_out;
        
      private:
        _0RL_boxed_seq1_octet* _pd_seq;
      };

      class _0RL_boxed_seq1_octet_out {
      public:
        inline _0RL_boxed_seq1_octet_out(_0RL_boxed_seq1_octet*& _s) : _data(_s) { _data = 0; }
        inline _0RL_boxed_seq1_octet_out(_0RL_boxed_seq1_octet_var& _s)
          : _data(_s._pd_seq) { _s = (_0RL_boxed_seq1_octet*) 0; }
        inline _0RL_boxed_seq1_octet_out(const _0RL_boxed_seq1_octet_out& _s) : _data(_s._data) {}
        inline _0RL_boxed_seq1_octet_out& operator = (const _0RL_boxed_seq1_octet_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline _0RL_boxed_seq1_octet_out& operator = (_0RL_boxed_seq1_octet* _s) {
          _data = _s;
          return *this;
        }
        inline operator _0RL_boxed_seq1_octet*&()  { return _data; }
        inline _0RL_boxed_seq1_octet*& ptr()       { return _data; }
        inline _0RL_boxed_seq1_octet* operator->() { return _data; }

        inline CORBA::Octet& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        _0RL_boxed_seq1_octet*& _data;

      private:
        _0RL_boxed_seq1_octet_out();
        _0RL_boxed_seq1_octet_out& operator=(const _0RL_boxed_seq1_octet_var&);
      };

#ifndef __org_momg_mboxedRMI_mseq1__octet__
#define __org_momg_mboxedRMI_mseq1__octet__

      class seq1_octet;

      class seq1_octet_Helper {
      public:
        static void add_ref(seq1_octet*);
        static void remove_ref(seq1_octet*);
        static void marshal(seq1_octet*, cdrStream&);
        static seq1_octet* unmarshal(cdrStream&);
      };

      typedef _CORBA_Value_Var    <seq1_octet,seq1_octet_Helper> seq1_octet_var;
      typedef _CORBA_Value_Member <seq1_octet,seq1_octet_Helper> seq1_octet_member;
      typedef _CORBA_Value_OUT_arg<seq1_octet,seq1_octet_Helper> seq1_octet_out;

#endif // __org_momg_mboxedRMI_mseq1__octet__

      class seq1_octet :
        public CORBA::DefaultValueRefCountBase
      {
      public:
        typedef seq1_octet_var _var_type;

        inline seq1_octet() {
          _pd_boxed = new _0RL_boxed_seq1_octet;
        }
        inline seq1_octet(const _0RL_boxed_seq1_octet& _v) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_v);
        }
        inline seq1_octet(const seq1_octet& _v) :
          ValueBase (_v), DefaultValueRefCountBase (_v) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_v._pd_boxed.in());
        }
        inline seq1_octet(CORBA::ULong _max) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_max);
        }
        inline seq1_octet(CORBA::ULong _max, CORBA::ULong _len, CORBA::Octet* _val, CORBA::Boolean _rel=0) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_max, _len, _val, _rel);
        }



        inline seq1_octet& operator=(const _0RL_boxed_seq1_octet& _v) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_v);
          return *this;
        }

        inline const _0RL_boxed_seq1_octet& _value() const {
          return _pd_boxed.in();
        }
        inline _0RL_boxed_seq1_octet& _value() {
          return _pd_boxed.inout();
        }
        inline void _value(const _0RL_boxed_seq1_octet& _v) {
          _pd_boxed = new _0RL_boxed_seq1_octet(_v);
        }

        inline const _0RL_boxed_seq1_octet& _boxed_in() const {
          return _pd_boxed.in();
        }
        inline _0RL_boxed_seq1_octet& _boxed_inout() {
          return _pd_boxed.inout();
        }
        inline _0RL_boxed_seq1_octet_out _boxed_out() {
          return _pd_boxed.out();
        }

        inline CORBA::ULong maximum() const {
          return _pd_boxed->maximum();
        }
        inline CORBA::ULong length() const {
          return _pd_boxed->length();
        }
        inline void length(CORBA::ULong _len) {
          _pd_boxed->length(_len);
        }

        inline CORBA::Octet& operator[](CORBA::ULong _i) {
          return _pd_boxed[_i];
        }

      

        static seq1_octet* _downcast(ValueBase*);

#ifdef OMNI_HAVE_COVARIANT_RETURNS
        virtual seq1_octet* _copy_value();
#else
        virtual CORBA::ValueBase* _copy_value();
#endif

        // omniORB internal
        virtual const char* _NP_repositoryId() const;
        virtual const char* _NP_repositoryId(CORBA::ULong& _hashval) const;

        virtual const _omni_ValueIds* _NP_truncatableIds() const;

        virtual CORBA::Boolean _NP_custom() const;
        virtual CORBA::Boolean _NP_box() const;

        virtual void* _ptrToValue(const char* id);

        static void _NP_marshal(seq1_octet*, cdrStream&);
        static seq1_octet* _NP_unmarshal(cdrStream&);

        virtual void _PR_marshal_state(cdrStream&) const;
        virtual void _PR_unmarshal_state(cdrStream&);
        virtual void _PR_copy_state(seq1_octet*);

        static _core_attr const char* _PD_repoId;

      protected:
        ~seq1_octet();
      private:
        void operator=(const seq1_octet&);

        _0RL_boxed_seq1_octet_var _pd_boxed;
      };

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE omg
  _CORBA_MODULE_BEG

    _CORBA_MODULE boxedRMI
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_org
_CORBA_MODULE_BEG

  _CORBA_MODULE omg
  _CORBA_MODULE_BEG

    _CORBA_MODULE boxedRMI
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_seq1__octet
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_seq1__octet
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_seq1__octet
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_seq1__octet
#endif

#endif  // __seq1__octet_hh__

